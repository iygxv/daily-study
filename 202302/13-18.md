# 2023/2/13 - 2023/2/18

## 2023/2/13
- 继续学习webpack

- 闲暇之余

  for...in 和 for...of 的区别？

  for···of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口的数据结构 (数组、对象等)并且返回各项的值，和 ES3 中的 for··.in 的区别如下

  - for··of 遍历获取的是对象的键值，for··in 获取的是对象的键名

  - for··· in 会遍历对象的整个原型链，性能非常差不推荐使用，而for···of 只遍历当前对象不会遍历原型链

    ```js
    
    class A {
      constructor() {
        this.name = 'gx'
        this.age = 18
      }
      test2() {
         console.log('test2')
      }
    }
    A.prototype.test = function() {
      console.log('test')
    }
    
    const a = new A()
    
    for(let key in a){
      console.log(`in--- ${key}`)
      // in--- name
      // in--- age
      // in--- test
    }
    
    for(let key of Object.keys(a)){
      console.log(`of--- ${key}`)
      // in--- name
      // in--- age
    }
    ```
  
    
  
  - 对于数组的遍历，for···in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for···of 只返回数组的下标对应的属性值
  
  **总结:**
  
  for...in循环主要是为了遍历对象而生，不适用于遍历数组;
  
  or...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。
  
- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。

- **constructor**判断类型的问题，如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了，例如

  ```js
  function A() {}
  function B() {}
  
  const a = new A()
  console.log(a.constructor === A) // true
  
  a.__proto__ = B.prototype
  console.log(a.constructor === A)  // false
  console.log(a.constructor === B)  // true
  ```
  
- **Object.prototype.toString.call()**为什么需要call

  因为toString方法在对象上才能用来判断类型,也就是

  ```js
  const a = {}
  a.toString() // '[object Object]'
  ```

  但是在Array、function等**类型作为Object的实例，都重写了toString方法**， 因此，无法用于判断类型

  ```js
  const a = []
  const c = function c() {}
  a.toString() // ''
  c.toString() // 'function c() {}'
  ```

  因此需要通过call来改变this的执行， 使之指向`Object`

- typeof null 的结果为什么是`object`？

  在计算机中，object的类型标签是`000`, 而null的类型标签全是0， 因此typeof null 是object

## 2023/2/14

## 2023/2/15

## 2023/2/16

## 2023/2/17

## 2023/2/18

## 2023/2/19